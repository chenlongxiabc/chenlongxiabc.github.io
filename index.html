<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Everything is possible !">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Chen">
<meta property="og:description" content="Everything is possible !">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen">
<meta name="twitter:description" content="Everything is possible !">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Chen</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/18/STL-源码分析deque/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/18/STL-源码分析deque/" itemprop="url">STL 源码分析deque</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-18T11:09:10+08:00">
                2017-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/18/STL-源码分析deque/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/18/STL-源码分析deque/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/18/STL-源码分析deque/" class="leancloud_visitors" data-flag-title="STL 源码分析deque">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>deque是双端队列，支持快速随机访问。在前后位置插入/删除元素较快，它是vector和array的组合体，等下从结构中就可以看到，其实还应该加上list。string在侯捷老师后面的视频没有具体说明，但是在primer中说它和vector相似，因此结构不会很难。</p>
<h2 id="deque结构"><a href="#deque结构" class="headerlink" title="deque结构"></a>deque结构</h2><p><img src="https://github.com/chenlongxiabc/MarkdownPhotos/raw/master/deque.png" alt="deque"></p>
<p>deque的结构设计很巧妙。deque中是以buffer为存储单位，当存储空间不够时，它会增加一个buffer的空间，buffer的大小在旧版中可以指定，后面则默认设置了。上图中的buffer就是可以存储8个int的空间。中间的map其实是一个vector，注意这个vector是用来模拟deque的，意思就是vector的元素不是从头往后放置的，而是从中间到两边放置存储，因此当vector需要扩充时，元素是被copy到中间位置。vector中放置的是指针，该指针指向相应的buffer，这里就有点像list了。</p>
<p>iterator包含了四个指针，其代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></div><div class="line"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</div><div class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">    <span class="keyword">typedef</span> Ptr pointer;</div><div class="line">    <span class="keyword">typedef</span> Ref reference;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</div><div class="line">    <span class="keyword">typedef</span> T** map_pointer;</div><div class="line">    <span class="keyword">typedef</span> __deque_iterator self;</div><div class="line"></div><div class="line">    T* cur;</div><div class="line">    T* first;</div><div class="line">    T* last;</div><div class="line">    map_pointer node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中cur指向当前元素值，first指向buffer的首元素，finish则指向buffer的尾元素。node类型为指针的指针，指向map即vector容器中的指向buffer的指针。</p>
<p>了解完deque的基本结构，下面看deque中定义的函数。下面是insert函数，在position处插入一个元素其值为x。（注意position是一个位置迭代器）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type &amp;x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (position.cur == start.cur)&#123; <span class="comment">//如果安插点在最前端</span></div><div class="line">        push_front(x);</div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur)&#123;</div><div class="line">        push_back(x);</div><div class="line">        iterator tmp = finish;</div><div class="line">        --tmp;</div><div class="line">        <span class="keyword">return</span> tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> insert_aux(position, x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当元素插入位置在最前端或者后端时都可以借助push_front()和push_back()函数来完成。当插入位置在中间时需要借助辅助函数，其操作和vector的insert_aux类似。另外一个比较重要的操作是设置指针值，见下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指向指针的指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</div><div class="line">    node = new_node;</div><div class="line">    first = *new_node;</div><div class="line">    last = first + difference_type(buffer_size());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>new_node解引用得到一个指针即map中所存的值，该值又指向buffer。last指针只需要在first上移动buffer_size()即可。</p>
<p>最后说一下stack 和 queue的底层容器都可选择list 或 dequeue，但是两者都不允许遍历，也不提供iterator。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>若有错误，欢迎讨论。所有博客欢迎分享，转载，但请声明出处，严禁抄袭，仅用于学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/12/STL-源码分析vector-array-forward-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/STL-源码分析vector-array-forward-list/" itemprop="url">STL 源码分析vector,array,forward_list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T10:39:38+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/12/STL-源码分析vector-array-forward-list/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/12/STL-源码分析vector-array-forward-list/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/12/STL-源码分析vector-array-forward-list/" class="leancloud_visitors" data-flag-title="STL 源码分析vector,array,forward_list">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>vector,array,forward_list应该是容器中较简单的类型。下面对部分顺序容器类型进行一个简单的总结。<br>vector是可变大小数组，元素是连续存储的，因此支持随机访问。在尾部之外的其他位置插入删除元素很慢，因为需要进行元素的移动操作。array是固定大小的容器，编译期间就可以确定大小。同样是顺序存储支持快速随机访问。forward_list和list相似，只不过前者是单向，后者是双向，等下文章会说forward_list的结构。两者都不是顺序存储的，因此不支持随机访问的操作，但是优点是插入删除的速度很快。deque，string在后面的文章继续说明。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector定义的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></div><div class="line"><span class="title">class</span> <span class="title">vector</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">    <span class="keyword">typedef</span> value_type* iterator; <span class="comment">// T*</span></div><div class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    iterator start;</div><div class="line">    iterator finish;</div><div class="line">    iterator end_of_storage;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> start;&#125;</div><div class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> finish;&#125;</div><div class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size_type(end() - begin());</div><div class="line">    &#125;</div><div class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size_type(end_of_storage -  begin());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> begin() == end();</div><div class="line">    &#125;</div><div class="line">    reference <span class="keyword">operator</span>[] (size_type n) &#123;</div><div class="line">        <span class="keyword">return</span> *(begin() + n);</div><div class="line">    &#125;</div><div class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *begin;&#125;</div><div class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *(end() - <span class="number">1</span>);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义比较简单，很好理解。其中要注意的是其迭代器是指针。每个操作都进行了相应的定义,注意大多数容器是前闭后开的区间，因此注意back()函数的定义，end()返回的是尾后迭代器，因此要减1。<br>vector有一个很重要的函数就是push_back()。下面是push_back的源代码和相应的注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</div><div class="line">        <span class="comment">//判断还有存储空间可用，直接在尾后迭代器</span></div><div class="line">        <span class="comment">//位置构造元素</span></div><div class="line">        construct(finish, x);</div><div class="line">        ++finish;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="comment">//没有存储空间可以使用</span></div><div class="line">        insert_aux(end(), x);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 函数模板insert_aux()定义</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">calss</span> <span class="title">Alloc</span>&gt;</span></div><div class="line"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;::insert_aux(iterator position, <span class="keyword">const</span> T &amp;x) &#123;</div><div class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</div><div class="line">        <span class="comment">//复制最后位置元素</span></div><div class="line">        construct(finish, *(finish <span class="number">-1</span>));</div><div class="line">        ++finish;</div><div class="line">        T x_copy = x;</div><div class="line">        <span class="comment">//从后向前复制元素，相当于把position到(finish-2)</span></div><div class="line">        <span class="comment">//的元素统一向后移动一位。</span></div><div class="line">        copy_backward(position, finish<span class="number">-2</span>, finish<span class="number">-1</span>);</div><div class="line">        *position = x_copy;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//没有备用空间</span></div><div class="line">        <span class="keyword">const</span> size_type old_size = size();</div><div class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span>*old_size:<span class="number">1</span>;</div><div class="line">        iterator new_start = data_allocator::allocate(len);</div><div class="line">        iterator new_finish = new_start;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//建立完新空间开始拷贝元素,第一步拷贝position位置前的元素</span></div><div class="line">            new_finish = uninitialized_copy(start, position, new_start);</div><div class="line">            <span class="comment">//构造新元素x</span></div><div class="line">            construct(new_finish, x);</div><div class="line">            ++new_finish;</div><div class="line">            <span class="comment">//第二步拷贝position位置后的元素</span></div><div class="line">            new_finish = uninitialized_copy(position, finish, new_finish);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span>(...) &#123;</div><div class="line">            <span class="comment">//异常处理</span></div><div class="line">            <span class="comment">//销毁元素</span></div><div class="line">            destroy(new_start, new_finish);</div><div class="line">            <span class="comment">//收回空间</span></div><div class="line">            data_allocator::deallocate(new_start, len);</div><div class="line">            <span class="comment">//抛出异常</span></div><div class="line">            <span class="keyword">throw</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个设计就是在push_back()函数和insert_aux函数中都进行了是否还有存储空间的判断，原因是不仅push_back函数会用到insert_aux函数，其他函数也可能用到该函数，所以这样增加了该函数的通用性。</p>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>array 和 vector 一样都支持随机访问，但是其大小是固定的。下面看看array的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span>&#123;</span></div><div class="line">    <span class="keyword">typedef</span> _Tp          value_type;</div><div class="line">    <span class="keyword">typedef</span> _Tp*         pointer;</div><div class="line">    <span class="keyword">typedef</span> value_type*  iterator;</div><div class="line"></div><div class="line">    value_type _M_instance[_Nm ? _Nm :<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[_Nm]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中iterator也是指针，不是定义的一个复杂的模板类。</p>
<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p>forward_list是单向链表，应该说实现上和list很像。下面看forward_list的模型图。<br><img src="https://github.com/chenlongxiabc/MarkdownPhotos/raw/master/forward_list.png" alt="forward_list"><br>在forward_list中有两个函数可以注意下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> iterator(<span class="keyword">this</span>-&gt;_M_impl._M_head._M_next);</div><div class="line">&#125;</div><div class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> iterator(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>forward_list中有一个伪头节点蓝色标记的，end()返回的实际上是一个空的节点。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>若有错误，欢迎讨论。所有博客欢迎分享，转载，但请声明出处，严禁抄袭，仅用于学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/08/STL源码分析iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/STL源码分析iterator/" itemprop="url">STL源码分析iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T09:27:09+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/08/STL源码分析iterator/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/08/STL源码分析iterator/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/08/STL源码分析iterator/" class="leancloud_visitors" data-flag-title="STL源码分析iterator">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>迭代器在容器中扮演着重要角色。在使用算法的过程中，我们也需要用到迭代器。迭代器可以看作是smart pointer，它是标准库中定义的一个class type。</p>
<h2 id="Iterator-定义"><a href="#Iterator-定义" class="headerlink" title="Iterator 定义"></a>Iterator 定义</h2><p>下面这段代码是标准库中对list_iterator的一个定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></div><div class="line"><span class="title">struct</span> __<span class="title">list_iterator</span>&#123;</div><div class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">    <span class="keyword">typedef</span> Ptr pointer;</div><div class="line">    <span class="keyword">typedef</span> Ref reference;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从定义中我们可以看到iterator内部有5种类型，而算法在在调用iterator过程中需要知道这5种类型是什么，然后才有接下来的操作。这时候就会出现一个问题，那么我们怎么区分普通的指针和iterator呢？普通指针也是可以用于标准算法的，例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span> &#125;;</div><div class="line"><span class="keyword">auto</span> m = find_if(vec.begin(), vec.end(), [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;a) &#123;<span class="keyword">return</span> a &gt; <span class="number">6</span>; &#125;);</div></pre></td></tr></table></figure>
<p>而对于iterator我们获取其中的5种类型方式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></div><div class="line"><span class="title">struct</span> <span class="title">iterator_traits</span>&#123;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Iterator_traits是萃取机，用于获取不同迭代器或者指针对应的5种类型。如下图所示：<br><img src="https://github.com/chenlongxiabc/MarkdownPhotos/raw/master/Iterator_traits.png" alt="Iterator_traits"><br>这种方式对于普通指针肯定是不行的，下面就利用了partial template specialization 的方法。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//partial specialization</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="title">struct</span> <span class="title">iterator_traits</span>(<span class="title">T</span>*) &#123;</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="title">struct</span> <span class="title">iterator_traits</span>(<span class="title">const</span> <span class="title">T</span>*) &#123;</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是当我们需要知道指针或者Iterator的类型时就可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需要知道I的value type时可这么写:</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, ...&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里实际上是用了template的参数推导机制。根据变量I的类型来进行选择，这样就得到了相应的5种类型，使得普通指针也能用到我们的Algorithm中。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>若有错误，欢迎讨论。所有博客欢迎分享，转载，但请声明出处，严禁抄袭，仅用于学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/STL源码分析List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/STL源码分析List/" itemprop="url">STL源码分析List</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T10:00:51+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/06/STL源码分析List/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/06/STL源码分析List/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/06/STL源码分析List/" class="leancloud_visitors" data-flag-title="STL源码分析List">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近在看侯捷老师的STL剖析课程。边看课顺便记下笔记，算是对自己的监督吧。侯捷老师的课程选用的是cygnus C++ 2.91.57 for windows 版本，虽然年代久远但是看起来要容易很多，而我看的是SGI的STL版本，内容上应该差不多，主要是阅读起来方便。最近在看书，我很喜欢侯捷老师书中的一句话，“天下大事必作于细”，与君共勉。</p>
<h2 id="List内容介绍"><a href="#List内容介绍" class="headerlink" title="List内容介绍"></a>List内容介绍</h2><p>List 在标准库中指的是双向链表，而我们在数据结构中自己定义的可能是单向链表，基本原理差不多。另外，要注意的是标准库的双向链表其实是环状链表，示意图如下：<br><img src="https://github.com/chenlongxiabc/MarkdownPhotos/raw/master/list.png" alt="list"><br>注意图中有一个灰色的节点，该节点就是我们常用的list<t>.end()尾后迭代器所指向的地方。但是要注意该节点不属于我们定义的list内容，因此对它解引用会出现越界的错误。</t></p>
<h2 id="List代码简析"><a href="#List代码简析" class="headerlink" title="List代码简析"></a>List代码简析</h2><p>下面的代码是对list_node的定义，从类模板的定义中可以知道，一个节点包括两个空指针和一个T类型的data。空指针其实可以换为list_node类型指针，后面的标准库中进行了更换。空指针是无类型指针，任何指针都可以直接赋值给它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="title">struct</span> __<span class="title">list_node</span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</div><div class="line">    void_pointer prev;</div><div class="line">    void_pointer next;</div><div class="line">    T data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>接下来看下运算符重载，这主要是针对list中iterator的运算符。iterator其实也是一个类模板。下面看看主要代码，代码中的类型定义不要太过于纠结，主要看其实现原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></div><div class="line"><span class="title">class</span> <span class="title">list</span>&#123;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> list_node* link_type;</div><div class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    link_type node;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></div><div class="line"><span class="title">struct</span> __<span class="title">list_iterator</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">    <span class="keyword">typedef</span> Ptr pointer;</div><div class="line">    <span class="keyword">typedef</span> Ref reference;</div><div class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</div><div class="line">    link_type node;</div><div class="line"></div><div class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*node).data;&#125;</div><div class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</div><div class="line">    self &amp; <span class="keyword">operator</span>++()</div><div class="line">    &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</div><div class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</div><div class="line">    &#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，我觉得首先要注意的是运算符重载的顺序，我们可以发现iterator的解引用重载发生在(-&gt;)操作符重载之前，而后置递增运算符在前置运算符之后，其中的目的很明显，主要是后一个要用到前一个，所以我们在用到运算符重载的时候也应该注意这样的顺序，减少代码量。</p>
<p>递增运算符重载肯定返回的是调用者本身的类型即iterator类型。所以是返回*this。而前置递增运算符返回的是+1之后的iterator，而这里的+1其实就是让原先的指针node变成下一个node。注意前置运算符返回的是引用，而后置运算符不是。后置运算符多加了一个函数参数int，加上该参数的目的是为了区分前置与后置运算符，理由是当我们在调用这两种运算符时，只有一个函数参数即iterator的对象，所以无法区分，因此加上了一个函数参数int。而我们在调用时却不用写成i++5，理由是编译器会给我们加上，然后就可以区分了。后置递增运算符需要先保存以前的对象，然后再利用前置运算符进行递增，饭后旧的iterator。</p>
<p>解引用和(-&gt;)运算符返回的类型有一定差别，分别是引用和指针。这两者最终还是调用的built-in type的操作。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;Foo&gt;::iterator ite;</div><div class="line">ite-&gt;method();</div><div class="line"><span class="comment">//相当于(*ite).method, *ite获得一个 Foo object;最后就是 object.method()</span></div><div class="line"><span class="comment">//相当于(&amp;(*ite))-&gt;method(); &amp;(*ite)得到一个对象指针，然后就相当于指针调用一个method;</span></div></pre></td></tr></table></figure>
<p>另外需要注意的是在后置运算符重载的定义中 self tmp = *this 调用的是复制构造函数而不是*重载运算符。++*this 调用的是前置运算符重载，因为这是存在的运算符优先级关系。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>若有错误，欢迎讨论。所有博客欢迎分享，转载，但请声明出处，严禁抄袭，仅用于学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/30/A-generative-vision-model-RCN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/A-generative-vision-model-RCN/" itemprop="url">A generative vision model - RCN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-30T21:35:24+08:00">
                2017-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/classic-Papers/" itemprop="url" rel="index">
                    <span itemprop="name">classic Papers</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/30/A-generative-vision-model-RCN/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/30/A-generative-vision-model-RCN/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/30/A-generative-vision-model-RCN/" class="leancloud_visitors" data-flag-title="A generative vision model - RCN">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Recursive cortical network (RCN) 是发表在science期刊上的一篇论文。论文中我觉得最好的想法是将contour和surface结合起来生成网络，英文翻译过来是递归皮质层网络(笑😀)。该模型对contour和surface分别进行了建模，其中surface使用的是条件随机场，这属于概率图模型的范畴（我仅仅是了解过，不太懂，据说在深度学习之前是CV的一个重要研究领域，有机会好好学习），contour采用的是compositional hierarchy of features （组合特征层级结构）。模型中对这两者进行了交互，用到了置信机制和动态规划来进行求解。论文中的细节没有看太懂，因为对这两者了解的都不够。后面补充知识后再补充笔记（😭）。目前，从别人复现代码看test要比train慢很多，所以从这点看论文是不太好的。</p>
<p>github 代码链接 <a href="https://github.com/vicariousinc/science_rcn" target="_blank" rel="external">https://github.com/vicariousinc/science_rcn</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/27/张量的奇异值分解-t-SVD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/27/张量的奇异值分解-t-SVD/" itemprop="url">张量的奇异值分解(t-SVD)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-27T20:13:08+08:00">
                2017-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tensor-decomposition/" itemprop="url" rel="index">
                    <span itemprop="name">tensor decomposition</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/27/张量的奇异值分解-t-SVD/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/27/张量的奇异值分解-t-SVD/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/10/27/张量的奇异值分解-t-SVD/" class="leancloud_visitors" data-flag-title="张量的奇异值分解(t-SVD)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/SVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/SVM/" itemprop="url">SVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T21:03:18+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/20/SVM/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/09/20/SVM/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/09/20/SVM/" class="leancloud_visitors" data-flag-title="SVM">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/低秩和稀疏分离的模型推导/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/02/低秩和稀疏分离的模型推导/" itemprop="url">低秩和稀疏分离的模型推导</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T09:16:47+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Matrix-in-mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Matrix in mathematics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/02/低秩和稀疏分离的模型推导/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/09/02/低秩和稀疏分离的模型推导/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/09/02/低秩和稀疏分离的模型推导/" class="leancloud_visitors" data-flag-title="低秩和稀疏分离的模型推导">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>低秩和稀疏分离的模型又有一个说法叫鲁棒的主成分分析(Robust Principal Component Analysis)，简称RPCA。<br><img src="https://github.com/chenlongxiabc/MarkdownPhotos/raw/master/RPCA.jpg" alt="RPCA"><br>在上图中低秩矩阵就是对应矩阵中的主成分，而sparse error matrix就是稀疏成分。RPCA在信号处理中有着很多实际的应用。<br><img src="https://github.com/chenlongxiabc/MarkdownPhotos/raw/master/rpca_application.jpg" alt="rpca_application"><br>上图中两个典型的应用分别是视频中的背景建模和人脸图像去阴影。在监控视频中，背景往往是固定不动的，是对应视频中的主成分，而运动部分在每一帧图像中所处的位置不同，并且所占比例很小，可以看作是稀疏成分。人脸图像去阴影，是对多张同一人脸进行去阴影，而每一张人脸图像中的阴影比例较小，并且分布的位置不同，所以阴影部分就是稀疏成分，而无阴影图像对应主成分。因此，这两个应用都可以通过RPCA来进行建模处理。注意上述的稀疏成分更多是经验性的描述，并没有给出明确的数学定义，具体的定义在文献中也没有给出，具体问题应该具体分析吧。</p>
<h2 id="RPCA数学建模及求解"><a href="#RPCA数学建模及求解" class="headerlink" title="RPCA数学建模及求解"></a>RPCA数学建模及求解</h2><p>这篇博客中介绍的是典型的RPCA数学建模方法，也是在这篇论文中“Robust Principal Analysis ?”提出的RPCA凸优化模型。这里应该注意RPCA分析的具体操作流程是首先把每一帧图像或者每一张图片进行了列向量化，然后把列向量按列排在一起，这样便构成了RPCA中的矩阵。对应的数学模型是：<br>$$M=L_0 + S_0$$<br>其中$M$对应的是列向量化的矩阵，$L_0$则对应的是矩阵中的低秩成分，$S_0$是稀疏成分。上述问题可以建模为：<br>$$ \text{min} \quad rank(L) + ||S||_0 \quad \text{s. t.} \quad M = L + S $$<br>模型的直观解释是主成分是低秩的，稀疏成分的非零元更少，所以对两者之和进行最小化求解就可以得到低秩和稀疏成分。但是，上述模型是非凸的，为了转化为凸优化模型求解的问题，需要进行凸松弛（凸放缩），把$rank(L)$转化为核范数$||L||_\ast$即奇异值之和，零范数转化为1范数。那么凸放缩后的数学模型是：<br>$$\text{min} \quad ||L||_\ast + || S ||_1 \quad \text{s. t.} \quad M = L + S $$<br>求解该模型的常用方法是Alternating Direction Method of Multipliers(ADMM)算法。首先写出模型的增广拉格朗日式子：<br>$$l(L,S,Y) = ||L||_\ast + \lambda ||S||_1 + \langle Y,M-L-S \rangle +\frac{\mu}{2}||M-L-S||_F^2$$，<br>ADMM 算法的更新公式为：<br>$$L_{k+1} = \text{arg min}_L ||L||_\ast + \frac{\mu}{2} ||M-L-S_k+\frac{Y}{\mu}||_F^2 \\<br>S_{k+1} = \text{arg min}_S \lambda ||S||_1 + \frac{\mu}{2}  ||M-L_k-S+\frac{Y}{\mu}||_F^2 \\<br>Y_{k+1} = Y_k + \mu (M-L_k-S_k)<br>$$<br>关于ADMM算法会在下一篇博客中进行介绍。<br>其中$L$的更新式子可以简化为求解如下问题<br>$$\text{arg min}_X \frac{1}{2}||X-Y||_F^2 + \tau ||X||_\ast$$<br>由于该问题是凸问题因此最小值的解唯一，我们假设其解为$\hat{X} = \mathcal{D}_{\tau}(Y)$，其中$\mathcal{D}_{\tau}(Y)=U\mathcal{S}_{\tau}(\Sigma)V^T$，截断操作$\mathcal{S}_{\tau}[x] = \text{sgn}(x)\text{max}(|x|-\tau,0)$。下面我们需要证明$\hat{X}$为该凸问题的解。这里只需要证明下式成立：<br>$$Y- \hat{X} \in \tau \partial ||\hat{X}||_\ast$$<br>假设矩阵$Y$可以分解成$Y=U_0\Sigma_0 V_0^T + U_1\Sigma_1 V_1^T$，其中$\Sigma_0$奇异值大于$\tau$，$\Sigma_1$奇异值小于$\tau$。因此我们可以得到<br>$\hat{X} = U_0 (\Sigma_0 -\tau I)V_0^T$，$Y-\hat{X} = \tau (U_0 V_0^T + W), W=\frac{1}{\tau} U_1 \Sigma_1 V_1^T$核范数导数的定义是一个集合，即</p>
<p>$$\partial ||E||_\ast  = \lbrace A B^T + D : A^TD=\mathbf{0}, DB= \mathbf{0}, ||D||_2 \leq 1 \rbrace$$</p>
<p>令$A=U_0, B=V_0, D=W$，由Y的SVD分解定义可知：$U_0^T U_1=\mathbf{0}$，因此，$A^TD=\mathbf{0}, DB= \mathbf{0}$。又因为$\Sigma_1$奇异值小于$\tau$，所以$||D||_2 \leq 1$。结论$Y-\hat{X} \in \tau \partial ||\hat{X}||_\ast$得证。<br>更新$S$的式子只需要进行求导就可以得到解，在此不再赘述，需要注意的是$||X||_1$是各元素的绝对值之和，因此求导时需要注意。<br>最后的更新算法即:</p>
<p><img src="https://github.com/chenlongxiabc/MarkdownPhotos/raw/master/RPCA_algorithm.jpg" alt="RPCA_algorithm"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章对RPCA问题作了简单的介绍和推导，文中的算法是比较经典的用凸优化的方法来求解RPCA问题，当然还有很多其他经典的方法，因为数学太差不想多说。若有错误，欢迎讨论。所有博客欢迎分享，转载，但请声明出处，严禁抄袭，仅用于学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/23/PCA-and-quadratically-regularized-PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/PCA-and-quadratically-regularized-PCA/" itemprop="url">主成分分析和二次正则化PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T16:26:11+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Matrix-in-mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Matrix in mathematics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/23/PCA-and-quadratically-regularized-PCA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/23/PCA-and-quadratically-regularized-PCA/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/23/PCA-and-quadratically-regularized-PCA/" class="leancloud_visitors" data-flag-title="主成分分析和二次正则化PCA">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主成分分析在信号处理中有着极其重要的作用，这里分析的主成分分析和机器学习中PCA降维略有差别，但是其实两者的实质是一样的。这篇博客会从矩阵理论的角度对主成分分析做一个细致的介绍。</p>
<h2 id="PCA-模型"><a href="#PCA-模型" class="headerlink" title="PCA 模型"></a>PCA 模型</h2><p>PCA在矩阵问题中的最初模型是找到秩为k的矩阵$Z$来近似矩阵$A$。优化模型如下：<br>$$ \text{minimize} \quad ||A-Z||_F^2 \\<br>\text{subject to} \quad rank(Z) \leq k$$<br>这里假设矩阵$Z$的大小是$Z\in R^{m \times n}$。由于$Z$的秩是小于等于k的，所以可以令$Z=XY$，其中$X\in R^{m \times k}$，$Y\in R^{k \times n}$(为了简便直接令$rank(Z)=k$)。那么模型转化为$$\text{minimize} \quad ||A-XY||_F^2 = ||\Sigma-U^{T}XYV||_F^2$$，所以可以直接求解得到$XY=U\Sigma_k V^{T}$，然后让$X=U_k\Sigma_k^{1/2}$，$Y=\Sigma_k^{1/2} V_k^{T}$。很显然$X$,$Y$的解不是唯一的。例如它们的取值还可以是$X=U_k\Sigma_k^{1/2}G_k$，$Y=G_k^{-1}\Sigma_k^{1/2} V_k^{T}$。</p>
<h2 id="二次正则化PCA"><a href="#二次正则化PCA" class="headerlink" title="二次正则化PCA"></a>二次正则化PCA</h2><p>为了对矩阵$X$和$Y$进行一定的约束，在目标函数中加上了二次正则项。这时求解过程会变得相对复杂些。我们首先看优化模型：<br>$$\text{minimize} ||A-XY||_F^2+r||X||_F^2+r||Y||_F^2$$<br>当然，$X\in R^{m \times k}$，$Y\in R^{k \times n}$。目标函数是一个二范数的凸函数，通过直接求导得出最小值。对$X$和$Y$的求导结果分别如下：<br>$$(XY-A)Y^{T} + rX=0, (XY-A)^{T}X + rY^{T} = 0$$其中的求导过程要用到矩阵迹的求导公式，$$||A||_F^2 = \sqrt{tr(A^{T}A)}$$<br>$$\frac{\partial}{X}Tr(B^{T}X^{T}CXB)=C^{T}XBB^{T}+CXBB^{T}$$<br>$$\frac{\partial}{X}Tr(AXB)=A^{T}B^{T} \quad \frac{\partial}{X}Tr(AX^{T}B)=BA$$<br>化简求导结果，我们可以得到如下等式，其中左边的等式乘以了$X^{T}$，右边等式乘以了$Y$。<br>$$X^{T}(A-XY)Y^{T}=rX^{T}X \quad Y(A-XY)^{T}X=rYY^{T}$$，所以$XX^{T}=Y^{T}Y$。利用上述结论重写我们的优化条件就是：<br>$$\left[<br>\begin{array}{cc}<br>-rI \quad A\\<br>A^{T} \quad -rI<br>\end{array}<br>\right] \left[<br>\begin{array}{c}<br>X\\<br>Y^{T}<br>\end{array}<br>\right] =<br>\left[<br>\begin{array}{c}<br>X\\<br>Y^{T}<br>\end{array}<br>\right] (X^{T}X)<br>$$<br>矩阵$X^{T}X$和矩阵$\left[<br>\begin{array}{cc}<br>-rI \quad A\\<br>A^{T} \quad -rI<br>\end{array}<br>\right]$有相同的特征值（注意是包含于的关系），并且特征向量张成的空间等于$\left[<br>\begin{array}{c}<br>X\\<br>Y^{T}<br>\end{array}<br>\right]$的子空间。假设$A=U\Sigma V$，那么矩阵$\left[<br>\begin{array}{cc}<br>-rI \quad A\\<br>A^{T} \quad -rI<br>\end{array}<br>\right]$ 的特征值为$-r\pm \sigma_i$，因为矩阵$X^{T}X$的特征值非负，所以其特征值为$-r+ \sigma_i(\sigma_i \geq r)$，对应的特征向量为<br>$\left[<br>\begin{array}{c}<br>u_i\\<br>v_i<br>\end{array}<br>\right]$。由于特征向量张成的空间等于$\left[<br>\begin{array}{c}<br>X\\<br>Y^{T}<br>\end{array}<br>\right]$的子空间。所以可以令$X=U_k(\Sigma_k - rI)^{\frac{1}{2}}$， $Y=(\Sigma_k - rI)^{\frac{1}{2}}V_k$，注意此时的$k$并不是前$k$个奇异值的含义，而是表示在正奇异值的集合中取出$k$个值。当然最后的结论肯定是前$k$个奇异值，只需要把我们的$X$和$Y$重新代入到目标函数中，就可以发现该结论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客从矩阵分析的角度对PCA和二次正则化PCA作了简单的介绍，里面涉及到的矩阵理论知识较多，但也总算写完了，并给出了不太好的理解。博客参考了论文《Generalized Low Rank Models》。若有错误，欢迎讨论。所有博客欢迎分享，转载，但请声明出处，严禁抄袭，仅用于学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/牛顿法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenlongxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Fulan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/牛顿法/" itemprop="url">牛顿法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T19:35:54+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Matrix-in-mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Matrix in mathematics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/14/牛顿法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/14/牛顿法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/14/牛顿法/" class="leancloud_visitors" data-flag-title="牛顿法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在凸优化问题的求解方法中有很多具体可行的优化方法，例如梯度下降法、牛顿法、交替方向乘子法（ADMM）等。这篇文章会对求解一般无约束问题的牛顿法做个简单粗略的介绍，让我们明白它的基本原理，知道如何使用它。复杂的证明和讨论不在文中涉及，毕竟不是数学专业，学的不深。</p>
<h2 id="牛顿法原理分析"><a href="#牛顿法原理分析" class="headerlink" title="牛顿法原理分析"></a>牛顿法原理分析</h2><p>首先我们从最简单的一维情况开始。它的基本思想是在现有的参考点附近对$f(x)$做二阶泰勒展开，然后找到一个极小点作为下一个估计值。假设$x_k$是当前的参考点，$x_{k+1}$是待求的下一个估计值,优化目标函数是$f(x)$。那么$f(x)$在$x_k$附近的二阶泰勒展开是$\varphi(x) = f(x_k) + f’(x_k)(x-x_k) + \frac{1}{2}f’’(x_k)(x-x_k)^2$,求$\varphi’(x)=0$的解即为下一个估计值$x_{k+1}$。<br>$$f’’(x-x_k)+f’(x_k)=0$$推出$x_{k+1} = x_k-\frac{f’(x_k)}{f’’(x_k)}$。</p>
<p>将上述一维情况推广到矩阵形式。我们的表达式会变为$$\varphi(\mathbf{x})=f(\mathbf{x_k})+\nabla f(\mathbf{x_k})^{T}(\mathbf{x}-\mathbf{x_k})+\frac{1}{2}(\mathbf{x}-\mathbf{x_k})^{T}\nabla^2 f(\mathbf{x_k})(\mathbf{x}-\mathbf{x_k}),$$其中$\nabla^2 f(\mathbf{x_k})$为Hessian矩阵，是Hermitte的。在这里应注意一点，$f(\mathbf{x_k})$是关于向量$\mathbf{x_k}$的函数，但是函数值是实数。所以要注意改写为泰勒展开式的形式。令$\varphi(\mathbf{x})=0$，得到$$\nabla f(\mathbf{x_k})+\nabla^2 f(\mathbf{x_k})(\mathbf{x}-\mathbf{x_k})=0，$$这里要注意矩阵求导的计算，其中$\frac{1}{2}(\mathbf{x}-\mathbf{x_k})^{T}\nabla^2 f(\mathbf{x_k})(\mathbf{x}-\mathbf{x_k})$求导得到$$\frac{1}{2}[\nabla^2 f(\mathbf{x_k})(\mathbf{x}-\mathbf{x_k})+[\nabla^2 f(\mathbf{x_k})]^{H}(\mathbf{x}-\mathbf{x_k})]，$$根据$\nabla^2 f(\mathbf{x_k})$为Hessian矩阵化简得到上述求导结果。最后求解得$\mathbf{x_{k+1}}=\mathbf{x_k}- \mathbf{H_k}^{-1}\nabla f(\mathbf{x_k})$。可以发现矩阵形式和一维情况很类似。当然，上述推导过程很重要的一点是优化函数在参考点的二阶导数或者Hessian矩阵存在。</p>
<h2 id="阻尼牛顿法简介"><a href="#阻尼牛顿法简介" class="headerlink" title="阻尼牛顿法简介"></a>阻尼牛顿法简介</h2><p>原始牛顿法由于迭代公式中没有步长因子，因此是定步长迭代。对于非二次型目标函数，有时会出现函数值上升，即$f(x_{k+1})&gt;f(x_k)$的情况。这说明原始牛顿法不能保证函数值稳定地下降。严重情况下会出现迭代点列${x_k}$发散而导致计算失败。阻尼牛顿法每次迭代方向仍采用$d_k=-\mathbf{H_k}^{-1}\nabla f(\mathbf{x_k})$，但是每次迭代需要沿着此方向作一维搜索以寻求最优的步长因子$\lambda_k$，用优化公式表示是$$\lambda_k=argmin_{\lambda\in R}f(x+\lambda d_k)。$$阻尼牛顿法实质是对步长进行了优化，当然除此之外，还有其他的优化方案。</p>
<h2 id="牛顿法的进一步修正"><a href="#牛顿法的进一步修正" class="headerlink" title="牛顿法的进一步修正"></a>牛顿法的进一步修正</h2><p>上述牛顿法作出了一个很重要的假设前提就是二阶导数或者Hessian矩阵存在，其中还要强调一点的是要保证Hessian矩阵正定。若Hessian矩阵奇异，那么不能确定后继点，简单理解就是对应一维情况时二阶泰勒展开的二次项系数为0，此时函数的泰勒展开是条直线，无法确定后继点。若Hessian矩阵非奇异，也未必正定，牛顿方向可能不是下降方向，简单说是二阶泰勒展开的二次项系数可能为负数，这样在选取后继点时，算法可能会失效。</p>
<p>为了解决Hessian矩阵非正定的情况，是修正$\nabla^2 f(\mathbf{x_k})$，构造出一个对称正定矩阵$\mathbf{G_k}$，从而得到$d_k=-\mathbf{G_k}^{-1}\nabla f(\mathbf{x_k})$，再沿此方向作一维搜索。构造矩阵$\mathbf{G_k}$的方法是令<br>$$\mathbf{G_k}=\nabla^2 f(\mathbf{x_k})+\epsilon_k \mathbf{I}$$。此时，若$\alpha_k$是$\nabla^2 f(\mathbf{x_k})$的特征值，那么$\mathbf{G_k}$的特征值是$\alpha_k + \epsilon_k$，原因可以结合对称矩阵是可相似对角化的去理解。因此，只要$\epsilon_k$足够大，就能保证$\mathbf{G_k}$的正定性。</p>
<p>其中需要我们注意的是当$\mathbf{x_k}$为鞍点时，有<br>$$\nabla f(\mathbf{x_k}) = 0, \nabla^2 f(\mathbf{x_k}) \text{不定}$$因此原来的搜索方向不能使用，此时的$d_k$应选取负曲率方向，即$d_k^{T} \nabla^2 f(\mathbf{x_k}) d_k &lt; 0$。这里涉及到负曲率方向的定义，在张贤达的《矩阵分析与应用》中说到，当矩阵$\mathbf{H}$是非线性函数$f(x)$的Hessian矩阵时，称满足$\mathbf{p^{H}Hp} &gt; 0$ 的向量$\mathbf{p}$为函数$f$的正曲率方向，满足$\mathbf{p^{H}Hp} &lt; 0$ 的向量$\mathbf{p}$为函数$f$的负曲率方向。标量$\mathbf{p}^{H}\mathbf{Hp}$称为函数$f$沿着方向$\mathbf{p}$的曲率。沿着负曲率方向进行一维搜索必能使目标函数值下降。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>牛顿法的迭代收敛速度很快，这里就要和传统的梯度下降法进行比较一下，梯度下降法只是利用了优化函数的一阶导数，相当于利用了速度的概念，而牛顿法利用了二阶导数，也就是梯度的梯度，相当于考虑了加速度的信息，所以收敛速度更快。更通俗的理解是如果我们的泰勒级数足够多，那么求其倒数为0，只需一步就可以直接求出最优解，当然这是极端情况，例如二次函数。但是，牛顿法涉及到求解Hessian矩阵，所以计算量、存储量很大，此篇博客参考了《最优化理论与算法》陈宝林老师的著作。若有错误，欢迎讨论。所有博客欢迎分享，转载，但请声明出处，严禁抄袭，仅用于学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/Fulan.jpg"
               alt="chenlongxi" />
          <p class="site-author-name" itemprop="name">chenlongxi</p>
           
              <p class="site-description motion-element" itemprop="description">Everything is possible !</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/chenlongxiabc" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:1223818238@qq.com" target="_blank" title="qqEMail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      qqEMail
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:diegefulan@hotmail.com" target="_blank" title="hotmail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      hotmail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenlongxi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://chenlongxiabc.disqus.com/count.js" async></script>
    

    

  




	





  








  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("MMDCAXa1lY8FERUIu9jyqSWf-gzGzoHsz", "MmMSDaS3C3wlFRr2ozqMO5Yi");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
